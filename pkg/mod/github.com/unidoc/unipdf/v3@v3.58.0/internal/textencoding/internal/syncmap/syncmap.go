//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_cdc :m }};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ed :m }};func (_cb *ByteRuneMap )Length ()int {_cb ._eb .RLock ();
defer _cb ._eb .RUnlock ();return len (_cb ._eg )};func (_ae *RuneByteMap )Write (r rune ,b byte ){_ae ._ag .Lock ();defer _ae ._ag .Unlock ();_ae ._fe [r ]=b };func (_efd *RuneStringMap )Write (r rune ,s string ){_efd ._ef .Lock ();defer _efd ._ef .Unlock ();
_efd ._ed [r ]=s ;};func (_bbg *RuneStringMap )Range (f func (_eed rune ,_ebe string )(_ff bool )){_bbg ._ef .RLock ();defer _bbg ._ef .RUnlock ();for _ece ,_efb :=range _bbg ._ed {if f (_ece ,_efb ){break ;};};};func (_be *RuneSet )Range (f func (_cg rune )(_da bool )){_be ._gaf .RLock ();
defer _be ._gaf .RUnlock ();for _beb :=range _be ._ac {if f (_beb ){break ;};};};type RuneSet struct{_ac map[rune ]struct{};_gaf _a .RWMutex ;};func (_cd *RuneSet )Exists (r rune )bool {_cd ._gaf .RLock ();defer _cd ._gaf .RUnlock ();_ ,_bg :=_cd ._ac [r ];
return _bg ;};func (_ab *RuneSet )Length ()int {_ab ._gaf .RLock ();defer _ab ._gaf .RUnlock ();return len (_ab ._ac )};func (_age *RuneUint16Map )Length ()int {_age ._cdd .RLock ();defer _age ._cdd .RUnlock ();return len (_age ._ea );};func (_gg *RuneByteMap )Length ()int {_gg ._ag .RLock ();
defer _gg ._ag .RUnlock ();return len (_gg ._fe )};func MakeRuneByteMap (length int )*RuneByteMap {_gec :=make (map[rune ]byte ,length );return &RuneByteMap {_fe :_gec };};func (_agb *RuneUint16Map )Delete (r rune ){_agb ._cdd .Lock ();defer _agb ._cdd .Unlock ();
delete (_agb ._ea ,r );};type RuneStringMap struct{_ed map[rune ]string ;_ef _a .RWMutex ;};func (_fef *RuneSet )Write (r rune ){_fef ._gaf .Lock ();defer _fef ._gaf .Unlock ();_fef ._ac [r ]=struct{}{};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ea :make (map[rune ]uint16 ,length )};
};type RuneByteMap struct{_fe map[rune ]byte ;_ag _a .RWMutex ;};func (_b *ByteRuneMap )Read (b byte )(rune ,bool ){_b ._eb .RLock ();defer _b ._eb .RUnlock ();_ec ,_c :=_b ._eg [b ];return _ec ,_c ;};type StringsTuple struct{Key ,Value string ;};func (_feb *StringsMap )Range (f func (_ggf ,_daa string )(_bbc bool )){_feb ._acc .RLock ();
defer _feb ._acc .RUnlock ();for _egc ,_adb :=range _feb ._ca {if f (_egc ,_adb ){break ;};};};type ByteRuneMap struct{_eg map[byte ]rune ;_eb _a .RWMutex ;};func (_eec *RuneStringMap )Read (r rune )(string ,bool ){_eec ._ef .RLock ();defer _eec ._ef .RUnlock ();
_fg ,_gc :=_eec ._ed [r ];return _fg ,_gc ;};func (_bbb *RuneByteMap )Range (f func (_d rune ,_dc byte )(_fb bool )){_bbb ._ag .RLock ();defer _bbb ._ag .RUnlock ();for _cc ,_ga :=range _bbb ._fe {if f (_cc ,_ga ){break ;};};};func (_eea *StringRuneMap )Range (f func (_ebb string ,_fgba rune )(_bea bool )){_eea ._gfc .RLock ();
defer _eea ._gfc .RUnlock ();for _gea ,_ad :=range _eea ._cdc {if f (_gea ,_ad ){break ;};};};func (_dd *RuneUint16Map )Range (f func (_dcf rune ,_edc uint16 )(_fgb bool )){_dd ._cdd .RLock ();defer _dd ._cdd .RUnlock ();for _aag ,_dg :=range _dd ._ea {if f (_aag ,_dg ){break ;
};};};type StringsMap struct{_ca map[string ]string ;_acc _a .RWMutex ;};func (_af *RuneStringMap )Length ()int {_af ._ef .RLock ();defer _af ._ef .RUnlock ();return len (_af ._ed )};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_eg :make (map[byte ]rune ,length )}};
func (_dge *StringRuneMap )Read (g string )(rune ,bool ){_dge ._gfc .RLock ();defer _dge ._gfc .RUnlock ();_eab ,_bd :=_dge ._cdc [g ];return _eab ,_bd ;};func (_de *RuneUint16Map )Write (r rune ,g uint16 ){_de ._cdd .Lock ();defer _de ._cdd .Unlock ();
_de ._ea [r ]=g ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_eef :=map[string ]string {};for _ ,_ccc :=range tuples {_eef [_ccc .Key ]=_ccc .Value ;};return &StringsMap {_ca :_eef };};func (_g *ByteRuneMap )Range (f func (_gd byte ,_egf rune )(_f bool )){_g ._eb .RLock ();
defer _g ._eb .RUnlock ();for _ge ,_fd :=range _g ._eg {if f (_ge ,_fd ){break ;};};};func (_fdg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fdg ._cdd .RLock ();defer _fdg ._cdd .RUnlock ();_fee ,_gcg :=_fdg ._ea [r ];return _fee ,_gcg ;};func (_fga *StringsMap )Read (g string )(string ,bool ){_fga ._acc .RLock ();
defer _fga ._acc .RUnlock ();_afa ,_ffb :=_fga ._ca [g ];return _afa ,_ffb ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_eg :m }};func (_eeb *RuneUint16Map )RangeDelete (f func (_aga rune ,_dda uint16 )(_ebeg bool ,_dab bool )){_eeb ._cdd .Lock ();
defer _eeb ._cdd .Unlock ();for _bf ,_ccg :=range _eeb ._ea {_bbe ,_cf :=f (_bf ,_ccg );if _bbe {delete (_eeb ._ea ,_bf );};if _cf {break ;};};};func (_bc *StringRuneMap )Length ()int {_bc ._gfc .RLock ();defer _bc ._gfc .RUnlock ();return len (_bc ._cdc );
};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ac :make (map[rune ]struct{},length )}};func (_ddd *StringsMap )Copy ()*StringsMap {_ddd ._acc .RLock ();defer _ddd ._acc .RUnlock ();_fdc :=map[string ]string {};for _df ,_bfb :=range _ddd ._ca {_fdc [_df ]=_bfb ;
};return &StringsMap {_ca :_fdc };};func (_bb *RuneByteMap )Read (r rune )(byte ,bool ){_bb ._ag .RLock ();defer _bb ._ag .RUnlock ();_aa ,_gf :=_bb ._fe [r ];return _aa ,_gf ;};func (_ba *StringsMap )Write (g1 ,g2 string ){_ba ._acc .Lock ();defer _ba ._acc .Unlock ();
_ba ._ca [g1 ]=g2 ;};func (_ee *ByteRuneMap )Write (b byte ,r rune ){_ee ._eb .Lock ();defer _ee ._eb .Unlock ();_ee ._eg [b ]=r };func (_fbe *StringRuneMap )Write (g string ,r rune ){_fbe ._gfc .Lock ();defer _fbe ._gfc .Unlock ();_fbe ._cdc [g ]=r ;};
type StringRuneMap struct{_cdc map[string ]rune ;_gfc _a .RWMutex ;};type RuneUint16Map struct{_ea map[rune ]uint16 ;_cdd _a .RWMutex ;};